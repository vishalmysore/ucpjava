Plan: ucpjava - Universal Commerce Protocol Java Implementation
Create a new Java project ucpjava as an extension to a2ajava implementing the Universal Commerce Protocol (UCP) for e-commerce checkout, payments, and order management. The project will follow UCP specification (YYYY-MM-DD versioning) with support for REST, MCP, A2A, and Embedded transport bindings, featuring payment handler framework, capability negotiation, runtime schema composition with lenient validation (warnings), annotation-driven configuration (@UCPCapability, @UCPHandler), and order management extension as priority.

Steps
Set up ucpjava project structure - Create pom.xml with dependencies (Spring Boot 3.2.4+, Jackson 2.16.2+, Everit JSON Schema Validator, Lombok). Mirror a2ajava structure: io.github.vishalmysore.ucp.{domain, client, server, handler, schema, negotiation, annotation, config} with subpackages for checkout, payment, order, discovery, and transport bindings (rest, mcp, a2a). Include resources/schemas for JSON schemas.

Create annotation framework - Define annotations in annotation: @EnableUCP (Spring Boot starter), @UCPBusiness (business role configuration), @UCPPlatform (platform role configuration), @UCPCapability (declare supported capabilities), @UCPHandler (register payment handlers). Build UCPAutoConfiguration in config following a2ajava's EnableAgent pattern for component scanning, handler registry initialization, and capability auto-discovery.

Implement core domain models with order management - Create checkout domain (CheckoutResponse, CheckoutCreateRequest, CheckoutUpdateRequest) in domain/checkout with UCP-compliant fields. Build payment domain (PaymentHandlerResponse, PaymentInstrument, CardPaymentInstrument, PaymentCredential). Implement order management models in domain/order: OrderConfirmation, OrderResponse, OrderStatus, OrderUpdateRequest supporting dev.ucp.shopping.order capability. Create discriminated union Message with MessageError (severity: recoverable/requires_buyer_input/requires_buyer_review, JSONPath), MessageWarning, MessageInfo for lenient validation reporting.

Build discovery, negotiation, and schema validation - Create UCPProfile, UCPDiscovery, Service, Capability models in domain/discovery with reverse-DNS namespaces. Implement UCPDiscoveryController at /.well-known/ucp following A2ACardController pattern using @UCPCapability annotations for auto-population. Create CapabilityNegotiator for intersection logic. Build SchemaManager in schema with lenient validation: compose schemas via allOf, validate requests, generate MessageWarning for schema violations but accept requests, populate messages array in responses.

Implement REST server with order operations - Create UCPCheckoutController in server/rest with endpoints: POST /ucp/v1/checkout-sessions, GET /ucp/v1/checkout-sessions/{id}, PATCH /ucp/v1/checkout-sessions/{id}, POST /ucp/v1/checkout-sessions/{id}/complete, DELETE /ucp/v1/checkout-sessions/{id}. Add UCPOrderController with: GET /ucp/v1/orders/{id}, PATCH /ucp/v1/orders/{id} (cancel, refund operations). Integrate CapabilityNegotiator via UCP-Agent header parsing, SchemaManager for lenient validation. Implement CheckoutService and OrderService with status state machines and message generation.

Build payment handler framework with annotation support - Create PaymentHandler interface in handler with methods: getName(), getVersion(), getHandlerDeclaration(), acquireInstrument(), processPayment(). Implement PaymentHandlerRegistry scanning @UCPHandler annotated classes. Build sample handlers: @UCPHandler("com.example.tokenizer") BusinessTokenizerHandler, @UCPHandler("com.platform.tokenizer") PlatformTokenizerHandler, @UCPHandler("com.encrypted.credential") EncryptedCredentialHandler. Implement credential binding validation and handler configuration injection via @UCPHandler properties.

Create multi-transport clients and unified controller - Build UCPRestClient in client/rest following a2ajava client pattern with methods: createCheckout(), getCheckout(), updateCheckout(), completeCheckout(), cancelCheckout(), getOrder(), updateOrder(). Create UCPUnifiedController in server/jsonrpc handling JSON-RPC methods for MCP/A2A bindings, reusing JSON-RPC infrastructure from a2ajava. Add UCPMCPA2AClient for JSON-RPC transport consumption.

Further Considerations
Order management capability scope - Should order operations support full lifecycle (view, cancel, refund, return, exchange) or start with read-only + cancel? Recommend starting with GET order + PATCH for cancel/refund, defer return/exchange to future iterations.

Handler annotation configuration - Should @UCPHandler support embedded config (e.g., @UCPHandler(name="...", version="...", configSchema="...")) or external configuration files? Recommend hybrid: annotation for metadata, Spring properties for runtime config (endpoints, credentials).

Shared code with a2ajava - Should ucpjava depend on a2ajava as library dependency for JSON-RPC infrastructure reuse, or copy relevant code? Recommend Maven dependency on a2ajava for JsonRpcController, JsonRpcRequest/Response classes to avoid duplication while maintaining separate domain models.